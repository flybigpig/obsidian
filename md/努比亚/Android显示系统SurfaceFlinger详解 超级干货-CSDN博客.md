本文详细讲解了[Android](https://so.csdn.net/so/search?q=Android&spm=1001.2101.3001.7020)显示系统SurfaceFlinger，文中通过示例代码介绍的非常详细。对大家的学习或工作具有一定的参考借鉴价值，需要的朋友可以参考下

###### 目录

-   [一、Android系统启动](https://www.jb51.net/article/232330.htm#_label0 "一、Android系统启动")
-   [二、SurfaceFlinger代码剖析\[Android 11\]](https://www.jb51.net/article/232330.htm#_label1 "二、SurfaceFlinger代码剖析[Android 11]")
    -   [1.【执行文件-surfaceflinger】](https://www.jb51.net/article/232330.htm#_lab2_1_0 "1.【执行文件-surfaceflinger】")
    -   [2.【动态库-libsurfaceflinger.so】](https://www.jb51.net/article/232330.htm#_lab2_1_1 "2.【动态库-libsurfaceflinger.so】")
    -   [3\. 服务启动配置文件：/frameworks/native/services/surfaceflinger/surfaceflinger.rc](https://www.jb51.net/article/232330.htm#_lab2_1_2 "3. 服务启动配置文件：/frameworks/native/services/surfaceflinger/surfaceflinger.rc")
    -   [4\. Surface 创建过程](https://www.jb51.net/article/232330.htm#_lab2_1_3 "4. Surface 创建过程")
        -   [①FramebufferNativeWindow](https://www.jb51.net/article/232330.htm#_label3_1_3_0 "①FramebufferNativeWindow")
        -   [②应用程序的本地窗口 - Surface](https://www.jb51.net/article/232330.htm#_label3_1_3_1 "②应用程序的本地窗口 - Surface")
        -   [③Surface的创建](https://www.jb51.net/article/232330.htm#_label3_1_3_2 "③Surface的创建")
        -   [④SurfaceFlinger服务框架：](https://www.jb51.net/article/232330.htm#_label3_1_3_3 "④SurfaceFlinger服务框架：")

### 一、Android系统启动

Android设备从按下开机键到桌面显示画面，大致过程如下图流程：

![](https://i-blog.csdnimg.cn/blog_migrate/cd890399410eae2de4f8fa3c4b57c73f.jpeg)

开机显示桌面、从桌面点击 App 图标到 Activity显示在屏幕上的过程又是怎样的呢？下面介绍Android系统中的“画家” - SurfaceFlinger.

SurfaceFlinger 启动过程：

![](https://i-blog.csdnimg.cn/blog_migrate/3c53ca8779eeebaf272539d02c1233c7.jpeg)

### 二、SurfaceFlinger代码剖析\[Android 11\]

代码路径：/frameworks/native/services/surfaceflinger/

SurfaceFlinger二进制分成surfaceflinger[可执行文件](https://so.csdn.net/so/search?q=%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020)（main入口）和libsurfaceflinger.so库文件（功能实现），由main\_surfaceflinger.cpp文件编译而成，Android.bp代码模块编译配置如下：

#### 1.【执行文件-surfaceflinger】

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p></td><td><p><code>...cc_binary {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: </code><code>"surfaceflinger"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>defaults: [</code><code>"surfaceflinger_defaults"</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>init_rc: [</code><code>"surfaceflinger.rc"</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>srcs: [</code><code>"main_surfaceflinger.cpp"</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>whole_static_libs: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libsigchain"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>shared_libs: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"android.frameworks.displayservice@1.0"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"android.hardware.configstore-utils"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"android.hardware.configstore@1.0"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"android.hardware.graphics.allocator@2.0"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libbinder"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libcutils"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libdisplayservicehidl"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libhidlbase"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libhidltransport"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"liblayers_proto"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"liblog"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libsurfaceflinger"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libtimestats_proto"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libutils"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>static_libs: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libserviceutils"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libtrace_proto"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ldflags: [</code><code>"-Wl,--export-dynamic"</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// TODO(b/71715793): These version-scripts are required due to the use of</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// whole_static_libs to pull in libsigchain. To work, the files had to be</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// locally duplicated from their original location</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// $ANDROID_ROOT/art/sigchainlib/</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>multilib: {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lib32: {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>version_script: </code><code>"version-script32.txt"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>},</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lib64: {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>version_script: </code><code>"version-script64.txt"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>},</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>},</code></p><p><code>}...</code></p></td></tr></tbody></table>

SurfaceFlinger可执行二进制文件surfaceflinger由main\_surfaceflinger.cpp文件独立编译而成，主要负责搭建进程启动环境：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p></td><td><p><code>int</code> <code>main(</code><code>int</code><code>, </code><code>char</code><code>**) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>signal(SIGPIPE, SIG_IGN);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// 从8.0开始，Android提供了hidl机制，将原先直接由JNI-&gt;Native-&gt;HAL的接口调用形式，统一规范成hidl service/client交互形式。</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// 该方式从一方面规范和统一了Android Framework和HAL的调用机制，但实际从项目维度，这种调用方式对性能上开销，将比直接调用的方式要花费更多的时间。</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>hardware::configureRpcThreadpool(</code><code>1</code> <code>/* maxThreads */</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>false</code> <code>/* callerWillJoin */</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>startGraphicsAllocatorService();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// When SF is launched in its own process, limit the number of</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// binder threads to 4.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ProcessState::self()-&gt;setThreadPoolMaxThreadCount(</code><code>4</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// start the thread pool</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sp&lt;ProcessState&gt; ps(ProcessState::self());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ps-&gt;startThreadPool();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// 创建SurfaceFlinger对象，由强指针指向。</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// SurfaceFlinger继承RefBase类，所以此处一旦new出对象赋给sp指针后，将立刻出发SurfaceFlinger类的onFirstRef方法的调用。</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// instantiate surfaceflinger</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::createSurfaceFlinger();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>setpriority(PRIO_PROCESS, </code><code>0</code><code>, PRIORITY_URGENT_DISPLAY);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>set_sched_policy(</code><code>0</code><code>, SP_FOREGROUND);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Put most SurfaceFlinger threads in the system-background cpuset</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Keeps us from unnecessarily using big cores</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Do this after the binder thread pool init</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(cpusets_enabled()) set_cpuset_policy(</code><code>0</code><code>, SP_SYSTEM);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// SurfaceFlinger类正式初始化</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// initialize before clients can connect</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>flinger-&gt;init();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// SurfaceFlinger向ServiceManager注册Binder服务，</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// 这样在其他进程中可以通过getService+SERVICE_NAME来获取SurfaceFlinger服务，继而可以和SurfaceFlinger类进行Binder通信。</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// publish surface flinger</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sp&lt;IServiceManager&gt; sm(defaultServiceManager());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, </code><code>false</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//里面的new DisplayService()方法调用HIDL定义接口 Return&lt;sp&lt;IDisplayEventReceiver &gt;&gt; getEventReceiver() override;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>startDisplayService(); </code><code>// dependency on SF getting registered above</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(SurfaceFlinger::setSchedFifo(</code><code>true</code><code>) != NO_ERROR) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ALOGW(</code><code>"Couldn't set to SCHED_FIFO: %s"</code><code>, strerror(errno));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// SurfaceFlinger类进入主循环（此处注意SurfaceFlinger类未继承Threads类，不遵循Threads类的接口执行顺序）</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// run surface flinger in this thread</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>flinger-&gt;run();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>0</code><code>;</code></p><p><code>}</code></p></td></tr></tbody></table>

HIDL接口介绍可以参考：[HIDL 接口文档  |  Android 开源项目  |  Android Open Source Project](https://source.android.google.cn/reference/hidl/ "HIDL 接口文档  |  Android 开源项目  |  Android Open Source Project")

#### 2.【动态库-libsurfaceflinger.so】

Android.bp代码模块编译配置如下：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p></td><td><p><code>...cc_library_shared {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>name: </code><code>"libsurfaceflinger"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>defaults: [</code><code>"libsurfaceflinger_defaults"</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cflags: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"-fvisibility=hidden"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"-Werror=format"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"-DREDUCE_VIDEO_WORKLOAD"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"-DUSE_AML_HW_ACTIVE_MODE"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>srcs: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>":libsurfaceflinger_sources"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>logtags: [</code><code>"EventLog/EventLogTags.logtags"</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>include_dirs: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"frameworks/native/vulkan/vkjson"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"frameworks/native/vulkan/include"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"hardware/amlogic/gralloc/amlogic"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"hardware/amlogic/hwcomposer/tvp"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"hardware/amlogic/gralloc"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>static_libs: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libomxutils_static@2"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"libamgralloc_ext_static@2"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cppflags: [</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"-fwhole-program-vtables"</code><code>, </code><code>// requires ThinLTO</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>],</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lto: {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>thin: </code><code>true</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>},</code></p><p><code>}...</code></p></td></tr></tbody></table>

上面提到的createSurfaceFlinger()中会调用new SurfaceFlinger()，然后会执行到：onFirstRef()：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p></td><td><p><code>void</code> <code>SurfaceFlinger::onFirstRef()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mEventQueue.init(</code><code>this</code><code>);</code></p><p><code>}</code></p></td></tr></tbody></table>

onFirstRef() 中会创建 Handler 并初始化: /frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p></td><td><p><code>//MessageQueue.cpp</code></p><p><code>void</code> <code>MessageQueue::init(</code><code>const</code> <code>sp&lt;SurfaceFlinger&gt;&amp; flinger)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mFlinger = flinger;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mLooper = </code><code>new</code> <code>Looper(</code><code>true</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mHandler = </code><code>new</code> <code>Handler(*</code><code>this</code><code>);</code></p><p><code>}</code></p></td></tr></tbody></table>

然后会执行到 SurfaceFlinger::init()，该方法主要功能是：

-   初始化 EGL
-   创建 HWComposer
-   初始化非虚拟显示屏
-   启动 EventThread 线程
-   启动开机动画

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p><p>80</p><p>81</p><p>82</p><p>83</p></td><td><p><code>// Do not call property_set on main thread which will be blocked by init</code></p><p><code>// Use StartPropertySetThread instead.</code></p><p><code>void</code> <code>SurfaceFlinger::init() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ALOGI(&nbsp; </code><code>"SurfaceFlinger's main thread ready to run. "</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"Initializing graphics H/W..."</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Mutex::Autolock _l(mStateLock);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//&nbsp;对于CompositionEngine 属性进行设置， 创建RenderEngine对象</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Get a RenderEngine for the given display / config (can't fail)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// TODO(b/77156734): We need to stop casting and use HAL types when possible.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Sending maxFrameBufferAcquiredBuffers as the cache size is tightly tuned to single-display.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mCompositionEngine-&gt;setRenderEngine(renderengine::RenderEngine::create(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>renderengine::RenderEngineCreationArgs::Builder()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.setPixelFormat(static_cast&lt;int32_t&gt;(defaultCompositionPixelFormat))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.setImageCacheSize(maxFrameBufferAcquiredBuffers)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.setUseColorManagerment(useColorManagement)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.setEnableProtectedContext(enable_protected_contents(</code><code>false</code><code>))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.setPrecacheToneMapperShaderOnly(</code><code>false</code><code>)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.setSupportsBackgroundBlur(mSupportsBlur)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.setContextPriority(useContextPriority</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>? renderengine::RenderEngine::ContextPriority::HIGH</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: renderengine::RenderEngine::ContextPriority::MEDIUM)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.build()));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mCompositionEngine-&gt;setTimeStats(mTimeStats);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>LOG_ALWAYS_FATAL_IF(mVrFlingerRequestsDisplay,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"Starting with vr flinger active is not currently supported."</code><code>);　　</code><code>//创建HWComposer对象并传入一个name属性，再通过mCompositionEngine-&gt;setHwComposer设置对象属性。</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mCompositionEngine-&gt;setHwComposer(getFactory().createHWComposer(getBE().mHwcServiceName));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mCompositionEngine-&gt;getHwComposer().setConfiguration(</code><code>this</code><code>, getBE().mComposerSequenceId);　　</code><code>//processDisplayHotplugEventsLocked(); 处理 任何初始热插拔和显示更改的结果　　//在此方法中主要有调用 initScheduler(displayId);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Process any initial hotplug and resulting display changes.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>processDisplayHotplugEventsLocked();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const</code> <code>auto display = getDefaultDisplayDeviceLocked();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>LOG_ALWAYS_FATAL_IF(!display, </code><code>"Missing internal display after registering composer callback."</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>LOG_ALWAYS_FATAL_IF(!getHwComposer().isConnected(*display-&gt;getId()),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"Internal display is disconnected."</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(useVrFlinger) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>auto vrFlingerRequestDisplayCallback = [</code><code>this</code><code>](bool requestDisplay) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// This callback is called from the vr flinger dispatch thread. We</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// need to call signalTransaction(), which requires holding</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// mStateLock when we're not on the main thread. Acquiring</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// mStateLock from the vr flinger dispatch thread might trigger a</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// deadlock in surface flinger (see b/66916578), so post a message</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// to be handled on the main thread instead.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>static_cast&lt;</code><code>void</code><code>&gt;(schedule([=] {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ALOGI(</code><code>"VR request display mode: requestDisplay=%d"</code><code>, requestDisplay);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mVrFlingerRequestsDisplay = requestDisplay;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>signalTransaction();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mVrFlinger = dvr::VrFlinger::Create(getHwComposer().getComposer(),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>getHwComposer()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.fromPhysicalDisplayId(*display-&gt;getId())</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.value_or(</code><code>0</code><code>),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>vrFlingerRequestDisplayCallback);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!mVrFlinger) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ALOGE(</code><code>"Failed to start vrflinger"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// initialize our drawing state</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mDrawingState = mCurrentState;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// set initial conditions (e.g. unblank default device)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>initializeDisplays();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>char</code> <code>primeShaderCache[PROPERTY_VALUE_MAX];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>property_get(</code><code>"service.sf.prime_shader_cache"</code><code>, primeShaderCache, </code><code>"1"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(atoi(primeShaderCache)) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>getRenderEngine().primeCache();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Inform native graphics APIs whether the present timestamp is supported:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const</code> <code>bool presentFenceReliable =</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>!getHwComposer().hasCapability(hal::Capability::PRESENT_FENCE_IS_NOT_RELIABLE);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mStartPropertySetThread = getFactory().createStartPropertySetThread(presentFenceReliable);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mStartPropertySetThread-&gt;Start() != NO_ERROR) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ALOGE(</code><code>"Run StartPropertySetThread failed!"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ALOGV(</code><code>"Done initializing"</code><code>);</code></p><p><code>}</code></p></td></tr></tbody></table>

首先看下如何创建 HWComposer：`frameworks/native/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp`

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p></td><td><p><code>//make_unique 相当于 new,(能够取代new 而且无需 delete pointer，有助于代码管理)。</code></p><p><code>std::unique_ptr&lt;HWComposer&gt; DefaultFactory::createHWComposer(</code><code>const</code> <code>std::string&amp; serviceName) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>std::make_unique&lt;android::impl::HWComposer&gt;(serviceName);</code></p><p><code>}</code></p></td></tr></tbody></table>

对于CompositionEngine进行初始化:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><p><code>std::unique_ptr&lt;compositionengine::CompositionEngine&gt; DefaultFactory::createCompositionEngine() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>compositionengine::impl::createCompositionEngine();</code></p><p><code>}</code></p></td></tr></tbody></table>

同样是通过make\_unique创建了 CompositionEngine对象：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><p><code>std::unique_ptr&lt;compositionengine::CompositionEngine&gt; createCompositionEngine() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>std::make_unique&lt;CompositionEngine&gt;();</code></p><p><code>}</code></p></td></tr></tbody></table>

再回到flinger->init()中processDisplayHotplugEventsLocked(); 处理任何初始热插拔和显示更改的结果，在此方法中主要有调用 initScheduler(displayId)：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p></td><td><p><code>void</code> <code>SurfaceFlinger::initScheduler(DisplayId primaryDisplayId) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mScheduler) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// In practice it's not allowed to hotplug in/out the primary display once it's been</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// connected during startup, but some tests do it, so just warn and return.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ALOGW(</code><code>"Can't re-init scheduler"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>auto currentConfig = HwcConfigIndexType(getHwComposer().getActiveConfigIndex(primaryDisplayId));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mRefreshRateConfigs =</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>std::make_unique&lt;scheduler::RefreshRateConfigs&gt;(getHwComposer().getConfigs(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>primaryDisplayId),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>currentConfig);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mRefreshRateStats =</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>std::make_unique&lt;scheduler::RefreshRateStats&gt;(*mRefreshRateConfigs, *mTimeStats,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>currentConfig, hal::PowerMode::OFF);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mRefreshRateStats-&gt;setConfigMode(currentConfig);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mPhaseConfiguration = getFactory().createPhaseConfiguration(*mRefreshRateConfigs);</code></p><p><code>　　 </code><code>// 处创建Scheduler对象</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// start the EventThread</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mScheduler =</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>getFactory().createScheduler([</code><code>this</code><code>](bool enabled) { setPrimaryVsyncEnabled(enabled); },</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>*mRefreshRateConfigs, *</code><code>this</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//创建app链接 和 sf链接&nbsp;&nbsp;&nbsp; mAppConnectionHandle =</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mScheduler-&gt;createConnection(</code><code>"app"</code><code>, mPhaseConfiguration-&gt;getCurrentOffsets().late.app,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>impl::EventThread::InterceptVSyncsCallback());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mSfConnectionHandle =</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mScheduler-&gt;createConnection(</code><code>"sf"</code><code>, mPhaseConfiguration-&gt;getCurrentOffsets().late.sf,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>[</code><code>this</code><code>](nsecs_t timestamp) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mInterceptor-&gt;saveVSyncEvent(timestamp);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mEventQueue-&gt;setEventConnection(mScheduler-&gt;getEventConnection(mSfConnectionHandle));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mVSyncModulator.emplace(*mScheduler, mAppConnectionHandle, mSfConnectionHandle,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mPhaseConfiguration-&gt;getCurrentOffsets());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mRegionSamplingThread =</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>RegionSamplingThread(*</code><code>this</code><code>, *mScheduler,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>RegionSamplingThread::EnvironmentTimingTunables());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Dispatch a config change request for the primary display on scheduler</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// initialization, so that the EventThreads always contain a reference to a</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// prior configuration.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// This is a bit hacky, but this avoids a back-pointer into the main SF</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// classes from EventThread, and there should be no run-time binder cost</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// anyway since there are no connected apps at this point.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const</code> <code>nsecs_t vsyncPeriod =</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(currentConfig).getVsyncPeriod();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mScheduler-&gt;onPrimaryDisplayConfigChanged(mAppConnectionHandle, primaryDisplayId.value,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>currentConfig, vsyncPeriod);</code></p><p><code>}</code></p></td></tr></tbody></table>

详细看下app、sf的链接:

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p></td><td><p><code>Scheduler::ConnectionHandle Scheduler::createConnection(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const</code> <code>char</code><code>* connectionName, nsecs_t phaseOffsetNs,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>impl::EventThread::InterceptVSyncsCallback interceptCallback) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>auto vsyncSource = makePrimaryDispSyncSource(connectionName, phaseOffsetNs);&nbsp;&nbsp;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>auto eventThread = std::make_unique&lt;impl::EventThread&gt;(std::move(vsyncSource), std::move(interceptCallback));&nbsp;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>createConnection(std::move(eventThread));</code></p><p><code>}</code></p></td></tr></tbody></table>

可以看到创建了DispSyncSource对象，且构造方法传入了四个值，dispSync对象，phaseOffset偏移量，traceVsync为true，name就是 app或 sf

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><p><code>DispSyncSource::DispSyncSource(DispSync* dispSync, nsecs_t phaseOffset, bool traceVsync,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const</code> <code>char</code><code>* name)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: mName(name),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mValue(base::StringPrintf(</code><code>"VSYNC-%s"</code><code>, name), </code><code>0</code><code>), </code><code>//对mValue进行了赋值，systrace上我们看到的 VSYNC-app VSYNC-sf 标签就是它</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mTraceVsync(traceVsync),&nbsp; </code><code>//mTraceVsync为true,在onDispSyncEvent方法中</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mVsyncOnLabel(base::StringPrintf(</code><code>"VsyncOn-%s"</code><code>, name)),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mDispSync(dispSync),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mPhaseOffset(base::StringPrintf(</code><code>"VsyncOffset-%s"</code><code>, name), phaseOffset)&nbsp;&nbsp; </code><code>//对mPhaseOffset进行初始化 vsync信号到来时候，sf、app的偏移量</code></p></td></tr></tbody></table>

所以我们在systrace上面看到的 VSYNC-app/VSYNC-sf 驼峰 0 1变化，来源于这个。

![](https://i-blog.csdnimg.cn/blog_migrate/b2a5fd08b4b13bb7b9b98862ee7e888c.jpeg)

创建EventThread对象，传入sf 或 app 相关联的vsyncSource对象:

<table><tbody><tr><td><p>1</p></td><td><p><code>auto eventThread = std::make_unique&lt;impl::EventThread&gt;(std::move(vsyncSource),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::move(interceptCallback));</code></p></td></tr></tbody></table>

说明：

-   1）每个ConnectionHandle 对象里有个 id，作为 Scheduler 对象中 mConnections 属性（map<id, Connection>）的键值，Connection 对象中又包含 ConnectionHandle、EventThreadConnection、EventThread 3个属性。
-   2）mScheduler->getEventConnection(mSfConnectionHandle) 中，以 mSfConnectionHandle 的 id 为键值，在 Scheduler 的 mConnections（unordered\_map<int64\_t, Connection>）中找到对应的Connection，并返回其 EventThreadConnection 成员属性。
-   3）getHwComposer().registerCallback() 中，依次调用 HwComposer、Device 的registerCallback() 方法，并在 Device 中 将 SurfaceFlinger 对象封装到 ComposerCallbackBridge 中；对于封装后的对象，依次调用 Composer、IComposerClient 的 registerCallback() 方法，注入到 IComposerClient 的实现类中。

相关问题：

-   ① 屏幕刷新速率比系统帧速率快:

此时，在前缓冲区内容全部映射到屏幕上之后，后缓冲区尚未准备好下一帧，屏幕将无法读取下一帧，所以只能继续显示当前一帧的图形，造成一帧显示多次，也就是卡顿。

-   ② 系统帧速率比屏幕刷新率快

此时，屏幕未完全把前缓冲区的一帧映射到屏幕，而系统已经在后缓冲区准备好了下一帧，并要求读取下一帧到屏幕，将会导致屏幕上半部分是上一帧的图形，而下半部分是下一帧的图形，造成屏幕上显示多帧，也就是屏幕撕裂。

为了解决上述问题，Android显示系统一般会有多级缓冲，即在屏幕刷新的同时在另外一个buffer准备下一帧数据，以此提高性能：

![](https://i-blog.csdnimg.cn/blog_migrate/0e186f7ab85aab3b4971fde077613c61.jpeg)

-   前缓冲区：用来显示内容到屏幕的帧缓冲区
-   后缓冲区：用于后台合成下一帧图形的帧缓冲区
-   垂直同步（VSync）：当屏幕从缓冲区扫描完一帧到屏幕上之后，开始扫描下一帧之前，发出的一个同步信号，该信号用来切换前缓冲区和后缓冲区。
-   屏幕刷新率（HZ）：代表屏幕在一秒内刷新屏幕的次数，Android手机一般为60HZ（也就是1秒刷新60帧，大约16.67毫秒刷新1帧）
-   系统帧速率（FPS）：代表了系统在一秒内合成的帧数，该值的大小由系统算法和硬件决定。

#### 3\. 服务启动配置文件：/frameworks/native/services/surfaceflinger/surfaceflinger.rc

上面发现服务配置文件也在Android.mk中被加载：LOCAL\_INIT\_RC := surfaceflinger.rc

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><p><code>service surfaceflinger /system/bin/surfaceflinger</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>class</code> <code>core animation</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>user system</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>group graphics drmrpc readproc</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>onrestart restart zygote</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>writepid /dev/stune/foreground/tasks</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>socket pdx/system/vr/display/client&nbsp;&nbsp;&nbsp;&nbsp; stream </code><code>0666</code> <code>system graphics u:object_r:pdx_display_client_endpoint_socket:s0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>socket pdx/system/vr/display/manager&nbsp;&nbsp;&nbsp; stream </code><code>0666</code> <code>system graphics u:object_r:pdx_display_manager_endpoint_socket:s0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>socket pdx/system/vr/display/vsync&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stream </code><code>0666</code> <code>system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0</code></p></td></tr></tbody></table>

#### 4\. Surface 创建过程

![](https://i-blog.csdnimg.cn/blog_migrate/4c2505330d7055d20a6d30095bfb96fb.jpeg)

Surface 创建的过程就是 Activity 显示的过程，在 ActivityThread.handleResumeActivity() 中调用了 Activity.makeVisible()具体实现：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><p><code>void</code> <code>makeVisible() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!mWindowAdded) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ViewManager wm = getWindowManager();</code><code>//此处 getWindowManager 获取的是 WindowManagerImpl 对象</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>wm.addView(mDecor, getWindow().getAttributes());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mWindowAdded = </code><code>true</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mDecor.setVisibility(View.VISIBLE);</code></p><p><code>}</code></p></td></tr></tbody></table>

WindowManagerImpl.java：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p></td><td><p><code>public</code> <code>void</code> <code>addView(</code><code>@NonNull</code> <code>View view, </code><code>@NonNull</code> <code>ViewGroup.LayoutParams params) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>applyDefaultToken(params);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mGlobal.addView(view, params, mDisplay, mParentWindow);</code></p><p><code>}</code></p></td></tr></tbody></table>

WindowManagerGlobal.java：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p></td><td><p><code>public</code> <code>void</code> <code>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>...</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//创建 ViewRootImpl</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ViewRootImpl root = </code><code>new</code> <code>ViewRootImpl(view.getContext(), display);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>view.setLayoutParams(wparams);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mViews.add(view);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mRoots.add(root);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mParams.add(wparams);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//设置 View</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>root.setView(view, wparams, panelParentView);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>...</code></p><p><code>}</code></p></td></tr></tbody></table>

创建 ViewRootImpl：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><p><code>public</code> <code>ViewRootImpl(Context context, Display display) {</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>//获取 IWindowSession的代理类</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code><code>(context, display, WindowManagerGlobal.getWindowSession(),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>false</code> <code>/* useSfChoreographer */</code><code>);</code></p><p><code>}</code></p></td></tr></tbody></table>

WindowManagerGlobal.java：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p></td><td><p><code>@UnsupportedAppUsage</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>static</code> <code>IWindowSession getWindowSession() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>synchronized</code> <code>(WindowManagerGlobal.</code><code>class</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(sWindowSession == </code><code>null</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>try</code> <code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Emulate the legacy behavior.&nbsp; The global instance of InputMethodManager</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// was instantiated here.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//获取 IMS 的代理类</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>IWindowManager windowManager = getWindowManagerService();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//经过 Binder 调用，最终调用 WMS</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sWindowSession = windowManager.openSession(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>IWindowSessionCallback.Stub() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>@Override</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>void</code> <code>onAnimatorScaleChanged(</code><code>float</code> <code>scale) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ValueAnimator.setDurationScale(scale);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code><code>catch</code> <code>(RemoteException e) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>throw</code> <code>e.rethrowFromSystemServer();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>sWindowSession;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

WindowManagerService.openSession：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><p><code>// -------------------------------------------------------------</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// IWindowManager API</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// -------------------------------------------------------------</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>@Override</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>IWindowSession openSession(IWindowSessionCallback callback) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//创建session对象</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>new</code> <code>Session(</code><code>this</code><code>, callback);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

再次经过 Binder 将数据写回 app 进程，则获取的便是 Session 的代理对象 IWindowSession。

创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法:

ViewRootImpl：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p></td><td><p><code>public</code> <code>void</code> <code>setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {</code></p><p><code>&nbsp;&nbsp;</code><code>synchronized</code> <code>(</code><code>this</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>requestLayout(); </code><code>//详见下面分析</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>...</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//通过 Binder调用，进入 system 进程的 Session</code></p><p><code>&nbsp;</code><code>　　　　res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　　　　　　getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　　　　　　mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　　　　　　mAttachInfo.mDisplayCutout, inputChannel,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　　　　　　mTempInsets, mTempControls);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>...</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></td></tr></tbody></table>

Session.java

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></td><td><p><code>@Override</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>int</code> <code>addToDisplayAsUser(IWindow window, </code><code>int</code> <code>seq, WindowManager.LayoutParams attrs,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>viewVisibility, </code><code>int</code> <code>displayId, </code><code>int</code> <code>userId, Rect outFrame,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Rect outContentInsets, Rect outStableInsets,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//调用WMS的addWindow方法&nbsp;&nbsp;&nbsp;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>mService.addWindow(</code><code>this</code><code>, window, seq, attrs, viewVisibility, displayId, outFrame,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>outContentInsets, outStableInsets, outDisplayCutout, outInputChannel,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>outInsetsState, outActiveControls, userId);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

WindowManagerService.java：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p><p>80</p><p>81</p><p>82</p><p>83</p></td><td><p><code>public</code> <code>int</code> <code>addWindow(Session session, IWindow client, </code><code>int</code> <code>seq,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>LayoutParams attrs, </code><code>int</code> <code>viewVisibility, </code><code>int</code> <code>displayId, Rect outFrame,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Rect outContentInsets, Rect outStableInsets,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>InsetsState outInsetsState, InsetsSourceControl[] outActiveControls,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>requestUserId) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Arrays.fill(outActiveControls, </code><code>null</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code><code>[] appOp = </code><code>new</code> <code>int</code><code>[</code><code>1</code><code>];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>boolean</code> <code>isRoundedCornerOverlay = (attrs.privateFlags</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>&amp; PRIVATE_FLAG_IS_ROUNDED_CORNERS_OVERLAY) != </code><code>0</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>appOp);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(res != WindowManagerGlobal.ADD_OKAY) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>res;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>WindowState parentWindow = </code><code>null</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>int</code> <code>callingUid = Binder.getCallingUid();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>int</code> <code>callingPid = Binder.getCallingPid();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>long</code> <code>origId = Binder.clearCallingIdentity();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>int</code> <code>type = attrs.type;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>synchronized</code> <code>(mGlobalLock) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!mDisplayReady) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>throw</code> <code>new</code> <code>IllegalStateException(</code><code>"Display has not been initialialized"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>...</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//创建 WindowState</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>WindowState win = </code><code>new</code> <code>WindowState(</code><code>this</code><code>, session, client, token, parentWindow,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>appOp[</code><code>0</code><code>], seq, attrs, viewVisibility, session.mUid, userId,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>session.mCanAddInternalSystemWindow);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(win.mDeathRecipient == </code><code>null</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Client has apparently died, so there is no reason to</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// continue.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ProtoLog.w(WM_ERROR, </code><code>"Adding window client %s"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>+ </code><code>" that is dead, aborting."</code><code>, client.asBinder());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>WindowManagerGlobal.ADD_APP_EXITING;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(win.getDisplayContent() == </code><code>null</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ProtoLog.w(WM_ERROR, </code><code>"Adding window to Display that has been removed."</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>WindowManagerGlobal.ADD_INVALID_DISPLAY;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// 调整 WindowManager的LayoutParams 参数</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>DisplayPolicy displayPolicy = displayContent.getDisplayPolicy();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>displayPolicy.adjustWindowParamsLw(win, win.mAttrs, callingPid, callingUid);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(res != WindowManagerGlobal.ADD_OKAY) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>res;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// 打开输入通道</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>boolean</code> <code>openInputChannels = (outInputChannel != </code><code>null</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>&amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == </code><code>0</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code>&nbsp; <code>(openInputChannels) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>win.openInputChannel(outInputChannel);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>...</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>displayContent.getInputMonitor().setUpdateInputWindowsNeededLw();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>boolean</code> <code>focusChanged = </code><code>false</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//当该窗口能接收按键事件，则更新聚焦窗口</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(win.canReceiveKeys()) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>false</code> <code>/*updateInputWindows*/</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(focusChanged) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>imMayMove = </code><code>false</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(imMayMove) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>displayContent.computeImeTarget(</code><code>true</code> <code>/* updateImeTarget */</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>...</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Binder.restoreCallingIdentity(origId);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>res;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

创建 SurfaceSession 对象，并将当前 Session 添加到 WMS.mSessions 成员变量。

Session.java：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p></td><td><p><code>void</code> <code>windowAddedLocked(String packageName) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mPackageName = packageName;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mRelayoutTag = </code><code>"relayoutWindow: "</code> <code>+ mPackageName;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mSurfaceSession == </code><code>null</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(DEBUG) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Slog.v(TAG_WM, </code><code>"First window added to "</code> <code>+ </code><code>this</code> <code>+ </code><code>", creating SurfaceSession"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mSurfaceSession = </code><code>new</code> <code>SurfaceSession();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ProtoLog.i(WM_SHOW_TRANSACTIONS, </code><code>"&nbsp; NEW SURFACE SESSION %s"</code><code>, mSurfaceSession);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mService.mSessions.add(</code><code>this</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mService.dispatchNewAnimatorScaleLocked(</code><code>this</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mNumWindow++;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

SurfaceSession 的创建会调用 JNI，在 JNI 调用 nativeCreate()。

android\_view\_SurfaceSession.cpp：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><p><code>static</code> <code>jlong nativeCreate(JNIEnv* env, jclass clazz) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>SurfaceComposerClient* client = </code><code>new</code> <code>SurfaceComposerClient();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>client-&gt;incStrong((</code><code>void</code><code>*)nativeCreate);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>reinterpret_cast&lt;jlong&gt;(client);</code></p><p><code>}</code></p></td></tr></tbody></table>

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p></td><td><p><code>static</code> <code>jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>jobject metadataParcel) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ScopedUtfChars name(env, nameStr);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sp&lt;SurfaceComposerClient&gt; client;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(sessionObj != NULL) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>client = android_view_SurfaceSession_getClient(env, sessionObj);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code><code>else</code> <code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>client = SurfaceComposerClient::getDefault();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>SurfaceControl *parent = reinterpret_cast&lt;SurfaceControl*&gt;(parentObject);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sp&lt;SurfaceControl&gt; surface;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>LayerMetadata metadata;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Parcel* parcel = parcelForJavaObject(env, metadataParcel);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(parcel &amp;&amp; !parcel-&gt;objectsCount()) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>status_t err = metadata.readFromParcel(parcel);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(err != NO_ERROR) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>jniThrowException(env, </code><code>"java/lang/IllegalArgumentException"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"Metadata parcel has wrong format"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>status_t err = client-&gt;createSurfaceChecked(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>String8(name.c_str()), w, h, format, &amp;surface, flags, parent, std::move(metadata));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(err == NAME_NOT_FOUND) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>jniThrowException(env, </code><code>"java/lang/IllegalArgumentException"</code><code>, NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>0</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code><code>else</code> <code>if</code> <code>(err != NO_ERROR) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>jniThrowException(env, OutOfResourcesException, NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>0</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>surface-&gt;incStrong((</code><code>void</code> <code>*)nativeCreate);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>reinterpret_cast&lt;jlong&gt;(surface.get());</code></p><p><code>}</code></p></td></tr></tbody></table>

通过以上JNI接口获取SurfaceComposerClient 对象，作为跟 SurfaceFlinger 通信的代理对象。

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p></td><td><p><code>void</code> <code>SurfaceComposerClient::onFirstRef() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//getComposerService() 将返回 SF 的 Binder 代理端的 BpSurfaceFlinger 对象</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(sf != nullptr &amp;&amp; mStatus == NO_INIT) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sp&lt;ISurfaceComposerClient&gt; conn;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//调用 SF 的 createConnection()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>conn = sf-&gt;createConnection();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(conn != nullptr) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mClient = conn;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mStatus = NO_ERROR;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></td></tr></tbody></table>

比如截屏接口就会通过SurfaceControl调用到其中的capture 接口：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><p><code>status_t ScreenshotClient::capture(</code><code>const</code> <code>sp&lt;IBinder&gt;&amp; display, ui::Dataspace reqDataSpace,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ui::PixelFormat reqPixelFormat, </code><code>const</code> <code>Rect&amp; sourceCrop,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t reqWidth, uint32_t reqHeight, bool useIdentityTransform,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ui::Rotation rotation, bool captureSecureLayers,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sp&lt;GraphicBuffer&gt;* outBuffer, bool&amp; outCapturedSecureLayers) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sp&lt;ISurfaceComposer&gt; s(ComposerService::getComposerService());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(s == nullptr) </code><code>return</code> <code>NO_INIT;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>status_t ret = s-&gt;captureScreen(display, outBuffer, outCapturedSecureLayers, reqDataSpace,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>reqPixelFormat, sourceCrop, reqWidth, reqHeight,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>useIdentityTransform, rotation, captureSecureLayers);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(ret != NO_ERROR) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>ret;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>ret;</code></p><p><code>}</code></p></td></tr></tbody></table>

然后具体看下核心的SurfaceFlinger实现：

SurfaceFlinger.cpp：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><p><code>sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//创建一个Client</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>const</code> <code>sp&lt;Client&gt; client = </code><code>new</code> <code>Client(</code><code>this</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>client-&gt;initCheck() == NO_ERROR ? client : nullptr;</code></p><p><code>}</code></p></td></tr></tbody></table>

回到之前，创建完 ViewRootImpl 对象后，接下来调用该对象的 setView() 方法。在 setView() 中调用了 requestLayout() 方法，现在具体来看下这个方法调用流程：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><p><code>@Override</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>void</code> <code>requestLayout() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!mHandlingLayoutInLayoutRequest) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>checkThread();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mLayoutRequested = </code><code>true</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>scheduleTraversals();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></td><td><p><code>@UnsupportedAppUsage</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>void</code> <code>scheduleTraversals() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!mTraversalScheduled) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mTraversalScheduled = </code><code>true</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();　　　　　　　</code><code>//启动TraversalRunnable</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mChoreographer.postCallback(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, </code><code>null</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>notifyRendererOfFramePending();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pokeDrawLockIfNeeded();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p></td><td><p><code>final</code> <code>class</code> <code>TraversalRunnable </code><code>implements</code> <code>Runnable {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>@Override</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>void</code> <code>run() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>doTraversal();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></td></tr></tbody></table>

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><p><code>void</code> <code>doTraversal() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mTraversalScheduled) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mTraversalScheduled = </code><code>false</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mProfile) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Debug.startMethodTracing(</code><code>"ViewAncestor"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>　　　　　　</code><code>//调用performTraversals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; performTraversals();</code></p><p><code>if</code> <code>(mProfile) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Debug.stopMethodTracing();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mProfile = </code><code>false</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p><p>80</p><p>81</p><p>82</p><p>83</p><p>84</p><p>85</p><p>86</p><p>87</p><p>88</p><p>89</p><p>90</p><p>91</p><p>92</p><p>93</p></td><td><p><code>private</code> <code>void</code> <code>performTraversals() {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// cache mView since it is used so much below...</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>View host = mView; </code><code>//它就是 DecorView</code></p><p><code>...</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mFirst || windowShouldResize || viewVisibilityChanged || cutoutChanged || params != </code><code>null</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>|| mForceNextWindowRelayout) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mForceNextWindowRelayout = </code><code>false</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(isViewVisible) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// If this window is giving internal insets to the window</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// manager, and it is being added or changing its visibility,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// then we want to first give the window manager "fake"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// insets to cause it to effectively ignore the content of</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// the window during layout.&nbsp; This avoids it briefly causing</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// other windows to resize/move based on the raw frame of the</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// window, waiting until we can finish laying out this window</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// and get back to the window manager with the ultimately</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// computed insets.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>insetsPending = computesInternalInsets &amp;&amp; (mFirst || viewVisibilityChanged);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>...</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>try</code> <code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(DEBUG_LAYOUT) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Log.i(mTag, </code><code>"host=w:"</code> <code>+ host.getMeasuredWidth() + </code><code>", h:"</code> <code>+</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>host.getMeasuredHeight() + </code><code>", params="</code> <code>+ params);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mAttachInfo.mThreadedRenderer != </code><code>null</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// relayoutWindow may decide to destroy mSurface. As that decision</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// happens in WindowManager service, we need to be defensive here</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// and stop using the surface in case it gets destroyed.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mAttachInfo.mThreadedRenderer.pause()) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Animations were running so we need to push a frame</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// to resume them</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mDirty.set(</code><code>0</code><code>, </code><code>0</code><code>, mWidth, mHeight);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// 关键函数relayoutWindow</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(DEBUG_LAYOUT) Log.v(mTag, </code><code>"relayout: frame="</code> <code>+ frame.toShortString()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>+ </code><code>" cutout="</code> <code>+ mPendingDisplayCutout.get().toString()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>+ </code><code>" surface="</code> <code>+ mSurface);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// If the pending {@link MergedConfiguration} handed back from</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// {@link #relayoutWindow} does not match the one last reported,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// WindowManagerService has reported back a frame from a configuration not yet</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// handled by the client. In this case, we need to accept the configuration so we</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// do not lay out and draw with the wrong configuration.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!mPendingMergedConfiguration.equals(mLastReportedMergedConfiguration)) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(DEBUG_CONFIGURATION) Log.v(mTag, </code><code>"Visible with new config: "</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>+ mPendingMergedConfiguration.getMergedConfiguration());</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>performConfigurationChange(mPendingMergedConfiguration, !mFirst,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>INVALID_DISPLAY </code><code>/* same display */</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>updatedConfiguration = </code><code>true</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code><code>catch</code> <code>(RemoteException e) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>...</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>boolean</code> <code>cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!cancelDraw) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mPendingTransitions != </code><code>null</code> <code>&amp;&amp; mPendingTransitions.size() &gt; </code><code>0</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>(</code><code>int</code> <code>i = </code><code>0</code><code>; i &lt; mPendingTransitions.size(); ++i) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mPendingTransitions.get(i).startChangingAnimations();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mPendingTransitions.clear();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//开始绘制，其中调用了draw(fullRedrawNeeded);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>performDraw();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code><code>else</code> <code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(isViewVisible) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// Try again</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>scheduleTraversals();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code><code>else</code> <code>if</code> <code>(mPendingTransitions != </code><code>null</code> <code>&amp;&amp; mPendingTransitions.size() &gt; </code><code>0</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>(</code><code>int</code> <code>i = </code><code>0</code><code>; i &lt; mPendingTransitions.size(); ++i) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mPendingTransitions.get(i).endChangingAnimations();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mPendingTransitions.clear();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mAttachInfo.mContentCaptureEvents != </code><code>null</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>notifyContentCatpureEvents();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mIsInTraversal = </code><code>false</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

再看下relayoutWindow的实现：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p></td><td><p><code>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>if</code> <code>(mSurfaceControl.isValid()) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!useBLAST()) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//先创建一个本地Surface,然后调用copyFrom&nbsp;&nbsp; 将SurfaceControl信息拷贝到Surface中</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mSurface.copyFrom(mSurfaceControl);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code><code>else</code> <code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>final</code> <code>Surface blastSurface = getOrCreateBLASTSurface(mSurfaceSize.x,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mSurfaceSize.y);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// If blastSurface == null that means it hasn't changed since the last time we</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// called. In this situation, avoid calling transferFrom as we would then</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// inc the generation ID and cause EGL resources to be recreated.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(blastSurface != </code><code>null</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>mSurface.transferFrom(blastSurface);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code><code>else</code> <code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>destroySurface();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}....</code></p></td></tr></tbody></table>

SurfaceControl 类可以看作是一个 wrapper 类，最后会执行 copyFrom() 将其返回给 App 客户端：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p></td><td><p><code>@UnsupportedAppUsage</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>void</code> <code>copyFrom(SurfaceControl other) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(other == </code><code>null</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>throw</code> <code>new</code> <code>IllegalArgumentException(</code><code>"other must not be null"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>long</code> <code>surfaceControlPtr = other.mNativeObject;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(surfaceControlPtr == </code><code>0</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>throw</code> <code>new</code> <code>NullPointerException(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"null SurfaceControl native object. Are you using a released SurfaceControl?"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//通过JNI获取源SurfaceControl</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>long</code> <code>newNativeObject = nativeGetFromSurfaceControl(mNativeObject, surfaceControlPtr);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>synchronized</code> <code>(mLock) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(newNativeObject == mNativeObject) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(mNativeObject != </code><code>0</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>nativeRelease(mNativeObject);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//保存到全局mNativeObject用于外部调用</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>setNativeObjectLocked(newNativeObject);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p></td></tr></tbody></table>

> Surface 显示过程总结：

在 App 进程中创建 PhoneWindow 后会创建 ViewRoot。ViewRoot 的创建会创建一个 Surface，这个 Surface 其实是空的，通过与 WindowManagerService 通信 copyFrom() 一个NativeSurface 与 SurfaceFlinger 通信时。

> 关于Native Window：

Native Window是OpenGL与本地窗口系统之间搭建了桥梁。整个GUI系统至少需要两种本地窗口：

-   （1）面向管理者（SurfaceFlinger）

SurfaceFlinger是系统中所有UI界面的管理者，需要直接或间接的持有“本地窗口”，此本地窗口是FramebufferNativeWindow。

-   （2）面向应用程序

这类本地窗口是Surface。

正常情况按照SDK向导生成APK应用程序，是采用Skia等第三方图形库，而对于希望使用OpenGL ES来完成复杂界面渲染的应用开发者来说，Android也提供封装的GLSurfaceView（或其他方式）来实现图形显示。

##### ①FramebufferNativeWindow

EGL需要通过本地窗口来为OpenGL/OpenGL ES创建环境。由于OpenGL/ES对多平台支持，考虑到兼容性和移植性。不同平台的本地窗口EGLNativeWindowType数据类型不同。

Android平台的数据类型是ANativeWindow，像是一份“协议”，规定了一个本地窗口的形态和功能。ANativeWindow是FramebufferNativeWindow的父类。

Android中，由于多缓冲技术，EGLNativeWindowType所管理的缓冲区最少2个，最大3个。

FramebufferNativeWindow初始化需要Golloc支持，步骤如下：

-   加载GRALLOC\_HARDWARE\_MODULE\_ID模块，参见上节。
-   分别打开fb和gralloc设备，打开后的设备由全局变量fbDev和grDev管理。
-   根据设备的属性来给FramebufferNativeWindow赋初值。
-   根据FramebufferNativeWindow的实现来填充ANativeWindow中的“协议”
-   其他一些必要的初始化

##### ②应用程序的本地窗口 - Surface

Surface也继承了ANativeWindow

<table><tbody><tr><td><p>1</p></td><td><p><code>class</code> <code>Surface : </code><code>public</code> <code>ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt;</code></p></td></tr></tbody></table>

Surface是面向Android系统中所有UI应用程序的，即它承担着应用进程中的UI显示需求。

需要面向上层实现（主要是Java层）提供绘制图像的画板。SurfaceFlinger需要收集系统中所有应用程序绘制的图像数据，然后集中显示到物理屏幕上。Surface需要扮演相应角色，本质上还是由SurfaceFlinger服务统一管理的，涉及到很多跨进程的通信细节。

##### ③Surface的创建

Surface将通过mGraphicBufferProducer来获取buffer,这些缓冲区会被记录在mSlots中数据中。mGraphicBufferProducer这一核心成员的初始化流程如下：

ViewRootImpl持有一个Java层的Surface对象（mSurface）。

ViewRootImpl向WindowManagerService发起relayout请求，此时mSurface被赋予真正的有效值，将辗转生成的SurfaceControl通过Surface.copyFrom()函数复制到mSurface中。

由此，Surface由SurfaceControl管理，SurfaceControl由SurfaceComposerClient创建。SurfaceComposerClient获得的匿名Binder是ISurfaceComposer，其服务端实现是SurfaceFlinger。而Surface依赖的IGraphicBufferProducer对象在Service端的实现是BufferQueue。

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><p><code>class</code> <code>SurfaceFlinger :</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>BinderService&lt;SurfaceFlinger&gt;, </code><code>//在ServiceManager中注册为SurfaceFlinger</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>BnSurfaceComposer,</code><code>//实现的接口却叫ISurfaceComposer</code></p></td></tr></tbody></table>

##### ④SurfaceFlinger服务框架：

Buffer，Consumer，Producer是“生产者-消费者”模型中的3个参与对象，如何协调好它们的工作是应用程序能否正常显示UI的关键。

Buffer是BufferQueue，Producer是应用程序，Consumer是SurfaceFlinger。

![](https://i-blog.csdnimg.cn/blog_migrate/bd75a07bb46daa79b25f3d9b3c15316b.jpeg)

Surface内部提供一个BufferQueue，与上层和SurfaceFlinger形成一个生产者消费者模型，上层对应Producer，SurfaceFlinger对应Consumer。三者通过Buffer产生联系，每个Buffer都有四种状态：

-   Free：可被上层使用;
-   Dequeued：出列，正在被上层使用;
-   Queued：入列，已完成上层绘制，等待SurfaceFlinger合成;
-   Acquired：被获取，SurfaceFlinger正持有该Buffer进行合成;

如此循环，形成一个Buffer被循环使用的过程（FREE-> DEQUEUED->QUEUED->ACQUIRED->FREE）。

BufferQueue中的mSlots数组用于管理期内的缓冲区，最大容器是32。数据缓冲区的空间是动态分配的，应用程序与SurfaceFlinger都是使用OpenGL ES来完成UI显示。Layer类在SurfaceFlinger中表示“层”，通俗地讲就是代表了一个“画面”，最终物理屏幕上的显示结果就是通过对系统中同时存在的所有“画面”进行处理叠加而成。

到此这篇关于Android显示系统SurfaceFlinger详解的文章就介绍到这了。希望对大家的学习有所帮助，也希望大家多多支持脚本之家。