#### 如果在 button 点击的时候，在 onClick 回调同步执行耗时超过5s的任务。点击一次会触发 ANR 吗？点击 2 次呢，3 次呢？

1. **ANR（应用无响应）机制简介**
    
    - 在 Android 系统中，ANR 是一种用于防止应用长时间无响应而导致用户体验下降的机制。当应用的主线程（也称为 UI 线程）被阻塞一段时间（通常为 5 秒），系统就会认为应用无响应，从而弹出 ANR 对话框。主线程主要负责处理用户界面的更新和交互事件，如处理按钮点击事件等。
2. **点击一次按钮的情况**
    
    - **同步执行耗时任务的影响**：如果在`onClick`回调中同步执行一个耗时超过 5 秒的任务，那么很可能会触发 ANR。因为`onClick`方法是在主线程中被调用的，这个长时间的任务会阻塞主线程，使得系统无法及时响应用户的其他操作（如返回键、菜单操作等）以及更新 UI，一旦阻塞时间超过 5 秒，就会触发 ANR。
    - **示例代码说明**：
        
        收起
        
        java
        
        ```
        public class MainActivity extends AppCompatActivity {
            Button button;
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);
                button = findViewById(R.id.button);
                button.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        try {
                            // 模拟一个耗时超过5秒的任务
                            Thread.sleep(6000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                });
            }
        }
        ```
        
          
        - 在这个示例中，当按钮被点击时，主线程会进入`onClick`方法并开始执行`Thread.sleep(6000)`，这会使主线程休眠 6 秒，超过了 5 秒的 ANR 阈值，很可能会导致 ANR。
3. **点击多次按钮的情况**
    
    - **点击两次按钮**：如果用户快速点击两次按钮，同样会触发 ANR。因为第二次点击事件会在主线程还被第一次点击事件的耗时任务阻塞时到来，这些事件会排队等待主线程处理。由于主线程仍然被阻塞在第一个任务中，后续的任务无法及时执行，而且整个阻塞时间会更长，更有可能触发 ANR。
    - **点击三次或更多次按钮**：与点击两次的情况类似，每次点击事件都会在主线程繁忙时排队等待处理。只要主线程被最初的耗时任务阻塞，不管后续点击多少次，都会导致排队的事件越来越多，进一步加剧主线程的阻塞情况，增加触发 ANR 的可能性。而且，这种情况下即使第一个耗时任务完成后，主线程需要处理大量积压的点击事件，也可能因为处理这些事件的时间过长而触发 ANR。

#### 如果在 activity 任意周期（onCreate,onResume等），同步执行耗时超过 5s（ANR时间）的任务，期间不进行点击，那会触发 Input ANR 吗？

1. **理解 ANR 类型和触发条件**
    
    - **ANR 的主要类型**：在 Android 系统中，ANR 主要分为两种类型，一种是 Input ANR（输入无响应），另一种是 Broadcast Receiver Time - out（广播接收器超时）。Input ANR 主要是由于应用没有在规定时间内响应输入事件（如触摸事件、按键事件等）而触发。
    - **触发 Input ANR 的常规场景**：通常情况下，当用户进行输入操作（如点击按钮），而应用的主线程因为长时间的任务阻塞，无法在 5 秒内处理该输入事件时，就会触发 Input ANR。
2. **在 Activity 生命周期方法中执行耗时任务的情况**
    
    - **不涉及输入事件处理**：如果在`onCreate`、`onResume`等 Activity 生命周期方法中同步执行耗时超过 5 秒的任务，并且期间没有用户输入操作，那么不会触发 Input ANR。因为 Input ANR 是与输入事件的响应时间相关的，没有输入事件等待处理，就不存在输入无响应的情况。
    - **系统响应和用户体验的影响**：不过，虽然不会触发 Input ANR，但这种长时间的任务执行会阻塞主线程，导致系统无法及时更新 UI 或者执行其他与用户体验相关的任务。例如，在`onResume`过程中执行一个耗时任务，可能会导致 Activity 显示延迟，用户看到的可能是一个空白或者部分加载的界面，直到任务完成。
3. **特殊情况说明**
    
    - **其他组件的间接影响**：如果在执行耗时任务的过程中，其他组件（如后台服务、广播接收器等）触发了与当前 Activity 相关的输入事件（这种情况相对较少），并且主线程由于正在执行的耗时任务无法及时响应，那么可能会触发 Input ANR。但这种情况需要特定的条件，例如一个广播接收器接收到一个需要在 Activity 中处理的广播消息，而 Activity 的主线程正忙于其他任务。


#### input事件的 iq，oq，wq 和aq

1. **Input 事件处理队列概述**
    
    - 在 Android 系统中，对于输入（Input）事件的处理涉及到多个队列，其中`iq`（Input Queue）、`oq`（Outbound Queue）、`wq`（Wait Queue）和`aq`（Async Queue）发挥着不同的作用。这些队列是系统为了高效、有序地处理输入事件而设置的，从事件的接收、预处理到最终的处理和分发，每个环节都有相应的队列参与。
2. **各队列详细介绍**
    
    - **`iq`（Input Queue）**
        - **定义和功能**：`iq`是输入事件进入系统后的第一个队列，主要用于接收和暂存来自各种输入设备（如触摸屏、键盘、鼠标等）的原始输入事件。它是事件的入口点，所有的输入事件首先会被放入这个队列。例如，当用户触摸屏幕时，触摸事件会以特定的格式（如 MotionEvent）被封装并放入`iq`。
        - **数据结构和特点**：`iq`通常是一个先进先出（FIFO）的队列结构。这确保了事件按照接收的顺序进行处理，避免了事件顺序混乱的问题。其内部存储的事件包含了详细的输入信息，如事件类型（按下、抬起、移动等）、事件发生的坐标（对于触摸事件）等。
    - **`oq`（Outbound Queue）**
        - **定义和功能**：`oq`主要用于在事件预处理后，暂存即将发送到目标窗口或视图进行处理的事件。在输入事件从`iq`取出后，系统会对其进行一些初步的处理（如过滤、转换等），处理后的事件会被放入`oq`。这个队列起到了一个中间过渡的作用，将经过初步整理的事件传递给下一个处理阶段。
        - **与其他队列的关系**：它接收来自`iq`经过预处理后的事件，并且是向`wq`或`aq`发送事件的源头。例如，如果一个输入事件需要等待目标窗口的某些条件满足后才能处理，那么它会在`oq`中等待合适的时机被发送到`wq`。
    - **`wq`（Wait Queue）**
        - **定义和功能**：`wq`用于存放那些需要等待特定条件满足后才能被处理的输入事件。这些条件可能包括目标窗口的状态（如窗口是否可见、是否处于焦点状态等）、系统资源的可用性（如内存是否足够处理该事件所引发的操作）等。当事件在`oq`中被判定需要等待时，就会被放入`wq`。
        - **事件处理时机**：一旦等待的条件满足，`wq`中的事件会被取出并发送到目标窗口或视图进行处理。例如，如果一个窗口最初是不可见的，那么发送给这个窗口的触摸事件会被放入`wq`，当窗口变为可见后，事件就会从`wq`中取出并处理。
    - **`aq`（Async Queue）**
        - **定义和功能**：`aq`主要用于处理那些可以异步执行的输入事件。对于一些不依赖于当前 UI 线程状态或者不需要立即同步处理的事件，会被放入`aq`。这些事件可以在后台线程或者其他合适的时机进行处理，以避免阻塞主线程，提高系统的响应速度和效率。
        - **应用场景举例**：例如，一些与用户输入相关的日志记录或者非关键的状态更新等事件可以放入`aq`进行异步处理。这样，即使这些事件的处理需要一定的时间，也不会影响到用户界面的实时响应和交互。
#### Input 事件处理

1. **Input 事件的产生与传递路径**
    
    - **事件产生**：Input 事件起源于硬件输入设备，如触摸屏、键盘、鼠标（在支持鼠标的设备上）、游戏手柄等。当用户与这些设备交互时，硬件会产生相应的电信号，这些信号被转换为软件能够识别的事件。例如，当用户触摸屏幕时，触摸屏控制器会检测到触摸点的坐标、触摸压力（如果支持）等信息，并将其转换为`MotionEvent`。
    - **传递到系统内核**：硬件产生的信号经过设备驱动程序传递到 Android 系统内核。以触摸屏为例，触摸屏驱动程序会将触摸事件封装并通过内核的输入子系统（Input Subsystem）向上层传递。内核在这个过程中起到了承上启下的作用，它接收来自硬件的原始信号，并将其初步处理为系统能够理解的事件格式。
    - **从内核到系统服务（InputManagerService）**：内核将处理后的事件发送给`InputManagerService`（IMS）。IMS 是 Android 系统中负责管理和分发所有输入事件的服务，它运行在系统的进程空间中。在这里，事件会被进一步处理和分类，例如，不同类型的输入设备产生的事件会被区分开来，并且会根据事件的优先级等因素进行排序。
2. **InputManagerService 的处理流程**
    
    - **事件接收与解析**：`InputManagerService`首先接收来自内核的输入事件。对于每个事件，它会解析事件的类型（如按键事件、触摸事件等）、事件的参数（如按键码、触摸坐标等）以及事件的来源（如来自哪个输入设备）。例如，对于一个按键事件，它会解析出按键的代码（如`KEYCODE_BACK`代表返回键），以确定用户的操作意图。
    - **策略决策**：根据事件的类型和系统的当前状态，`InputManagerService`会做出策略决策。例如，如果系统处于锁屏状态，它可能会决定忽略某些非关键的触摸事件；如果是紧急的系统按键事件（如电源键事件），则会立即处理。这个过程涉及到与系统的其他组件（如窗口管理服务、电源管理服务等）的交互，以确保事件的处理符合系统的整体策略。
    - **目标窗口查找**：在确定事件需要被处理后，`InputManagerService`会查找事件的目标窗口。它会根据事件的坐标（对于触摸事件）和当前系统的窗口层次结构（通过与窗口管理服务协作）来确定哪个窗口应该接收这个事件。例如，当用户触摸屏幕时，`InputManagerService`会从顶层窗口开始向下查找，直到找到包含触摸点的窗口作为目标窗口。
3. **事件传递到目标窗口（Activity 或 View）**
    
    - **跨进程通信（如果需要）**：如果目标窗口所在的进程与`InputManagerService`所在的进程不同（例如，大多数应用的 Activity 都运行在独立的进程中），则需要进行跨进程通信。`InputManagerService`会通过 Binder 机制将事件发送到目标窗口所在的进程。这个过程涉及到进程间数据的打包、传输和解包，以确保事件能够准确无误地到达目标窗口。
    - **在目标窗口中的分发与处理**：事件到达目标窗口后，会在窗口内部进行分发。对于 Activity 来说，它会将事件分发给其包含的各个 View。这个分发过程是基于 View 的层次结构和事件分发机制进行的。例如，触摸事件会从 Activity 的根视图开始，按照视图的布局顺序和事件分发规则（如`onTouchEvent`、`dispatchTouchEvent`等方法的调用顺序）向下传递，直到某个 View 处理了这个事件或者事件被确定为无法处理而结束分发。
4. **View 对 Input 事件的处理方式**
    
    - **事件拦截与分发机制**：View 有一套完善的事件拦截和分发机制，主要通过`dispatchTouchEvent`、`onInterceptTouchEvent`和`onTouchEvent`这三个方法来实现。`dispatchTouchEvent`方法是事件分发的入口，它决定了事件是否应该分发给当前 View 以及后续的子 View。`onInterceptTouchEvent`方法可以在父 View 中拦截事件，阻止事件继续传递给子 View。`onTouchEvent`方法则是 View 处理事件的实际方法，当事件传递到一个 View 并且没有被拦截时，会调用这个方法来处理事件。
    - **不同类型 View 的处理差异**：不同类型的 View 对输入事件有不同的处理方式。例如，按钮（Button）View 主要关注点击事件，当用户触摸并抬起手指在按钮区域内时，按钮会触发`onClick`事件；而文本视图（TextView）可能更关注触摸移动事件，用于实现文本选择等功能。对于自定义的 View，开发者可以根据自己的需求重写上述事件处理方法，来实现特定的交互功能。

#### input事件是怎么找到对应窗口去分发

1. **通过 InputManagerService 和 WindowManagerService 协作定位**
    
    - **InputManagerService（IMS）的角色**：当输入事件（如触摸事件、按键事件）进入系统后，首先会到达`InputManagerService`。IMS 会对这些事件进行初步处理，包括解析事件类型、提取关键信息（如触摸坐标、按键码）等。以触摸事件为例，IMS 会获取触摸点的坐标信息，这些坐标是确定目标窗口的关键因素之一。
    - **WindowManagerService（WMS）的参与**：WMS 负责管理系统中的所有窗口，包括窗口的创建、销毁、布局以及可见性等。IMS 会与 WMS 协作来确定输入事件的目标窗口。WMS 维护了一个窗口层次结构（类似于树形结构），它记录了每个窗口的位置、大小、层级等信息。例如，在一个包含多个 Activity 的应用中，或者在有悬浮窗、对话框等多种窗口类型的场景下，窗口之间存在着上下层级关系，WMS 就是管理这些关系的核心组件。
    - **具体定位过程**：IMS 根据触摸事件的坐标，从 WMS 维护的窗口层次结构的顶层窗口开始，按照从顶向下的顺序检查每个窗口的位置和大小。当找到一个包含触摸点坐标的窗口时，这个窗口就被确定为目标窗口。对于按键事件，情况稍有不同。如果当前有焦点窗口（通过 WMS 记录的焦点状态来确定），那么按键事件通常会被发送到焦点窗口，因为焦点窗口是当前接收用户输入的主要窗口。
2. **使用命中测试（Hit Testing）技术**
    
    - **原理**：命中测试是一种用于确定触摸点位于哪个具体视图（View）上的技术。在 Android 系统中，当确定了输入事件的目标窗口后，还需要进一步在窗口内部确定具体是哪个视图来处理事件。每个窗口内部包含多个视图，它们组成了一个视图层次结构。命中测试从窗口的根视图（通常是一个`ViewGroup`）开始，递归地检查每个子视图的位置和大小。
    - **过程**：以触摸事件为例，根视图会检查触摸点是否在自己的范围内。如果在，它会继续检查它的子视图，直到找到最底层的、包含触摸点的视图。这个视图就是最终要接收和处理触摸事件的目标视图。例如，在一个包含按钮、文本视图等多个视图的布局中，当用户触摸屏幕时，命中测试会确定触摸点位于哪个视图上，可能是按钮视图（如果触摸点在按钮范围内），然后按钮视图就会接收并处理这个触摸事件。
    - **与窗口定位的关系**：命中测试是在窗口定位之后进行的一个细化步骤。先通过 IMS 和 WMS 确定目标窗口，然后在目标窗口内部通过命中测试确定目标视图。这两个步骤共同确保了输入事件能够准确地找到对应的处理单元，无论是窗口还是窗口内的具体视图。

