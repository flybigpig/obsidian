最近和几个之前一起做安卓的朋友喝酒，他最近在研究JVM，我们就简单的讨论了起来，他比我研究的深很多，我也不甘堕落，自己也开始研究了一下，写了4篇文章整理了一下自己的思路，Java虚拟机整体篇幅如下：

-   [Java虚拟机基础——1Java的内存模型](https://cloud.tencent.com/developer/article/1352474?from_column=20421&from=20421)
-   [Java虚拟机基础——2JVM运行时数据区](https://cloud.tencent.com/developer/article/1352478?from_column=20421&from=20421)
-   [Java虚拟机基础——3类加载机制](https://cloud.tencent.com/developer/article/1352482?from_column=20421&from=20421)
-   [Java虚拟机基础——4内存回收机制](https://cloud.tencent.com/developer/article/1353027?from_column=20421&from=20421)

本片文章内容如下：

-   1、硬件的效率与一致性
-   2、Java内存模型
-   3、重排序
-   4、JVM体系结构简介

多任务和高并发是衡量一台计算机处理器的能力重要指标之一。一般衡量一个[服务器](https://cloud.tencent.com/product/cvm/?from_column=20065&from=20065)性能的高低好坏，使用每秒事务处理数(Transactions Per Second，TPS)这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序并发能力有着非常密切的关系。在讨论Java内存模型和线程之前，先简单介绍一下硬件的效率与一致性。

### 一、硬件的效率与一致性

由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距。所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(cache)来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当匀速结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。

基于告诉缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性(Cache Coherence)。在多处理器系统中，每个处理器都有自己的告诉缓存，而他们又共享统一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议来保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的。

![](https://ask.qcloudimg.com/http-save/yehe-2957818/hlw0uil9cx.png)

一致性.png

除此之外，为了使得处理内部的运算单元尽可能的被充分利用，处理可能会对出入代码进行乱序执行(Out-Of-Order Execution)优化，处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果准确性。与处理器的乱序执行优化类似，Java虚拟机的即使编译器(JIT)中也有类似的指令重排序(Instruction Recorder)优化。

### 二、Java内存模型

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态姿态和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。

> Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存(可以与前面的处理器高速缓存类比)，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作(读取、赋值)都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对象工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。

![](https://ask.qcloudimg.com/http-save/yehe-2957818/kboof4vo9x.png)

Java内存.png

这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。

![](https://ask.qcloudimg.com/http-save/yehe-2957818/2vmkehzor5.png)

主内存.png

对普通变量，一个线程中更新的值，不能马上反应在其他变量中。如果需要在其他线程中立即可见，需要使用volatile关键字作为标识

-   1、原子性： 八种基本类型都具有原子性的。Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现的。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。
-   2、可见性：一个线程修改了变量，其他线程可以立即知道，保证可见性的方法：
    -   volatile
    -   synchronized(unlock)
    -   final(一旦初始化完成，其他线程就可见)
-   3、有序性：在本线程内，操作都是有序的；在线程外，操作都是无序的。在Java内存模型中，允许编译器和处理对执行进行重排序，但是重排序过程不会影响到单线程程序的执行，却影响到多线程并发执行的正确性。在Java里面，可以通过volatile关键字来保证一定的"有序性"。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程来执行同步代码，相当于让线程顺序执行同步代码，自然就保证了有序性。对于volatile，JMM(Java Memory Model)内存屏障插入策略：
    -   在每个volatile写操作的前面插入一个StoreStroe屏障
    -   在每个volatile写操作的后面插入一个StroeLoad屏障
    -   在每个volatile读操作的后面插入一个LoadLoad屏障
    -   在每个volatile读操作的后面插入一个LoadStore屏障

内存间交互操作：

关于主内存工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下8种操作来完成：

-   lock(锁定)：作用于主内存的变量，把一个变量标识为一条线程独占状态。
-   unlock(解锁)：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的编码那个才可以被其他线程锁定
-   read(读取)：作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
-   load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
-   use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作
-   assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码执行令时执行这个操作。
-   store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
-   write(写入)：作用于主内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中。

![](https://ask.qcloudimg.com/http-save/yehe-2957818/jtq5g3w50e.png)

内存.png

如果把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存，就要按顺序地执行store和write操作。每一个操作都是原子的，即执行期间不会被中断。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对内存中的变量啊a、b进行访问，可能的顺序是read a，read b，load b，load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

-   read和load、store和write操作之一单独出现
-   不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
-   不允许一个线程无原因地(没有发生过任何assign操作)把数据从工作内存同步回主内存。
-   一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
-   一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现。
-   如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量钱需要重新执行load或assign操作初始化量的值。
-   如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
-   对一个变量执行unlock操作之前，必须先把此变量同步到主内存中(执行store和write操作)。

### 三、重排序

在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：

1.  编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。
2.  指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3.  内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：

![](https://ask.qcloudimg.com/http-save/yehe-2957818/tezgb69bhq.png)

image.png

为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。

### 四、JVM体系结构简介

为了展示虚拟机进程和.class文件的关系，特意画了下面一张图：

![](https://ask.qcloudimg.com/http-save/yehe-2957818/k0k55wdpvv.png)

虚拟机.png

通过上面这幅图片，我们编译后的.class文件是作为Java虚拟机的原料被输入到Java虚拟机内部的，那么具体由谁来做这一部分工作呢？其实在Java虚拟机内部，有一个叫做类加载的子系统，这个子系统用来在运行时根据需要加载类。注意上面一句话中的"根据需要"4个字。在Java虚拟机执行过程中，只有他需要一个类的时候，才会调用类加载器来加载这个类，并不会再开始运行时加载所有类。就像一个人，只有饿的时候才去吃饭，而不是一次把一年的饭都吃到肚子里。一般来说，虚拟机加载类的时机，在第一次使用一个新的类的时候。我们将会在Java虚拟机基础——3类加载机制中详细讲解。

> 由于虚拟机加载的类，被加载到Java虚拟机内存中之后，虚拟机会读取并执行它里面存在的字节码指令。虚拟机中执行字节码指令的部分叫做执行引擎。就像一个人，不把饭吃下去就完事了，还要进行消化，执行引擎就相当于一个人的肠胃系统。在执行的过程中，还会把各个class文件动态的连接起来。关于执行引擎的具体行为和动态链接相关的内容也会在Java虚拟机基础——3类加载机制中详细讲解。

我们知道，Java虚拟机会进行自动内存管理。具体来说就是自动释放没有用的对象，而不需要程序员编写代码来释放分配的内存。这部分工作由垃圾收集子系统负责。从上面的论述可以知道，一个Java虚拟机实例在运行过程中有3个子系统来保障它的正常运行，分别是：

-   类加载系统
-   执行引擎系统
-   垃圾回收系统

如下图：

![](https://ask.qcloudimg.com/http-save/yehe-2957818/pu6u9ctzls.png)

JVM三个子系统.png

虚拟机的运行，必须加载.class文件，并且执行class文件中的字节码指令。它做这么多事情，必须需要自己的空间。就像人吃下去的东西首先要放到胃里。虚拟机也需要空间来存放这个数据。首先，加载字节码，需要一个单独的内存空间来存放；一个线程的执行，也需要内存空间来维护方法的调用关系，存放方法中的数据和中间计算结果；在执行的过程中，无法避免的要创建对象，创建的对象需要一个专门的内存空间来存放。关于虚拟机运行时区域的内容，我们将在Java虚拟机基础——2JVM运行时数据区中详细讲解。

大家喜欢就点赞，您的每一次点赞，都是我努力和进步的动力！您可能想不到：您的小小一按，可能就会对另外一个人产生翻天覆地的影响。！最后谢谢您的支持与厚爱

本文参与 [腾讯云自媒体同步曝光计划](https://cloud.tencent.com/developer/support-plan)，分享自作者个人站点/博客。

原始发表：2018.10.03 ，如有侵权请联系 [cloudcommunity@tencent.com](mailto:cloudcommunity@tencent.com) 删除